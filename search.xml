<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>机器学习-聚类分析</title>
    <url>/2022/03/28/machine-learning1/</url>
    <content><![CDATA[<h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>大三</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(2)-链表</title>
    <url>/2021/06/25/shujujiegou2/</url>
    <content><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>链表</p>
<hr>
<h3 id="实验及代码"><a href="#实验及代码" class="headerlink" title="实验及代码"></a>实验及代码</h3><h4 id="Ex2-1"><a href="#Ex2-1" class="headerlink" title="Ex2-1"></a>Ex2-1</h4><ul>
<li>首先创建一个单链表：从键盘读入五个整数，按输入顺序形成单链表。将创建好的链表元素依次输出到屏幕上;</li>
<li>在已创建好的链表中插入一个元素：从键盘读入元素值和插入位置，调用插入函数完成插入操作。然后将链表元素依次输出到屏幕上;</li>
<li>在已创建好的链表中删除一个元素：从键盘读入欲删除的元素位置（序号），调用删除函数完成删除操作,然后将链表元素依次输出到屏幕上。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;node_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    node_type *head;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;list_type;</span><br><span class="line"></span><br><span class="line"><span class="function">node_type *<span class="title">init_sllist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node_type *head;</span><br><span class="line">    head = (node_type *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));</span><br><span class="line">    <span class="keyword">if</span>(head!=<span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        head-&gt;data = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;init error&quot;</span>);</span><br><span class="line">        head = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node_type *<span class="title">create_sllist</span><span class="params">(list_type *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the data element end with -1:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> x, counter = <span class="number">0</span>;</span><br><span class="line">    node_type *h, *newnode, *temp;</span><br><span class="line">    h = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        h = (node_type *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));</span><br><span class="line">        <span class="keyword">if</span>(h != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            h-&gt;data = x;</span><br><span class="line">            h-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;length = counter;</span><br><span class="line">        <span class="keyword">return</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    temp = h;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        newnode = (node_type *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));</span><br><span class="line">        <span class="keyword">if</span>(newnode != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            newnode-&gt;data = x;</span><br><span class="line">            counter++;</span><br><span class="line">            temp-&gt;next = newnode;</span><br><span class="line">            temp = newnode;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = counter;</span><br><span class="line">    <span class="keyword">return</span>(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sllist</span><span class="params">(list_type *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node_type *temp;</span><br><span class="line">    temp = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThese %d records are : \n&quot;</span>, <span class="built_in">list</span>-&gt;length);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nThe list is empty.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">list</span>-&gt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nLength of the list is %d.\n&quot;</span>, <span class="built_in">list</span>-&gt;length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sllist</span><span class="params">(list_type *<span class="built_in">list</span>, <span class="keyword">int</span> i, node_type *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="built_in">list</span>-&gt;length || i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%d is an invalid value\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    node_type * temp = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">while</span>(counter &lt; i<span class="number">-1</span> &amp;&amp; temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;      <span class="comment">//带头节点，不需要判断表首插入</span></span><br><span class="line">    p-&gt;next = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = p;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_sllist</span><span class="params">(list_type *<span class="built_in">list</span>, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( i &gt; <span class="built_in">list</span>-&gt;length || i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%d is an invalid value.\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    node_type *temp , *s;</span><br><span class="line">    temp = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">while</span>(counter &lt; i<span class="number">-1</span> &amp;&amp; temp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(counter != i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%d is invalid\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_silist</span><span class="params">(list_type *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node_type *p;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">list</span>-&gt;head-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">list</span>-&gt;head-&gt;next;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;next = <span class="built_in">list</span>-&gt;head-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list_type l;</span><br><span class="line">    <span class="keyword">int</span> p, newdata;</span><br><span class="line">    l.head = init_sllist();   <span class="comment">//头指针</span></span><br><span class="line">    l.head-&gt;next = create_sllist(&amp;l); </span><br><span class="line">    print_sllist(&amp;l);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//insert</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPlease enter the number to insert and its position.\n&quot;</span>);</span><br><span class="line">    node_type *newelem;</span><br><span class="line">    newelem = (node_type *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;p, &amp;newdata);</span><br><span class="line">    newelem-&gt;data = newdata;</span><br><span class="line">    insert_sllist(&amp;l, p, newelem);</span><br><span class="line">    print_sllist(&amp;l);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//delete</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPlease enter the position of the number to be delete.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">    delete_sllist(&amp;l, p);</span><br><span class="line">    print_sllist(&amp;l);</span><br><span class="line"></span><br><span class="line">    free_silist(&amp;l);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*疑惑：</span></span><br><span class="line"><span class="comment">需不需要给头节点 l 分配空间（主要是length）</span></span><br><span class="line"><span class="comment">以及分配之后如何释放</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解答：list中的head本身也占空间，init函数只是分配了head所指向的空间</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Ex2-2"><a href="#Ex2-2" class="headerlink" title="Ex2-2"></a>Ex2-2</h4><ul>
<li>创建一个单链表，其数据元素为整数，从键盘输入，输入0结束（注意0不放到链表内；</li>
<li>从键盘任意输入一个整数，在单链表中查询该数，如果单链表中已经存在这个数，就调用删除函数，删除该元素所在结点，并将单链表在删除前后的数据元素依次输出到屏幕上。如果单链表中不存在这个数，就调用插入函数，将这个数插入到单链表尾，并将单链表在插入前后的数据元素依次输出到屏幕上。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;node_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    node_type *head;</span><br><span class="line">&#125;list_type;</span><br><span class="line"></span><br><span class="line"><span class="function">node_type *<span class="title">init_silist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node_type *head;</span><br><span class="line">    head = (node_type*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        head-&gt;data = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;init error.&quot;</span>);</span><br><span class="line">        head = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node_type *<span class="title">create_sllist</span><span class="params">(list_type *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the data element end with 0:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> x, counter = <span class="number">0</span>;</span><br><span class="line">    node_type *h, *newnode, *temp;</span><br><span class="line">    h = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        h = (node_type *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));</span><br><span class="line">        <span class="keyword">if</span>(h != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            h-&gt;data = x;</span><br><span class="line">            h-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;length = counter;</span><br><span class="line">        <span class="keyword">return</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    temp = h;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        newnode = (node_type *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));</span><br><span class="line">        <span class="keyword">if</span>(newnode != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            newnode-&gt;data = x;</span><br><span class="line">            counter++;</span><br><span class="line">            temp-&gt;next = newnode;</span><br><span class="line">            temp = newnode;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = counter;</span><br><span class="line">    <span class="keyword">return</span>(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_silist</span><span class="params">(list_type *<span class="built_in">list</span>, <span class="keyword">int</span> x, <span class="keyword">int</span> place[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>, counter = <span class="number">1</span>, flag = <span class="number">0</span>;</span><br><span class="line">    node_type *temp = <span class="built_in">list</span>-&gt;head-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;data == x)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            place[j] = counter;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用数组place存储要删除的元素的位置</span></span><br><span class="line"><span class="comment">// 返回需删除的元素的位置</span></span><br><span class="line"><span class="comment">// 考虑有多个相同的元素需要删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sllist</span><span class="params">(list_type *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node_type *temp;</span><br><span class="line">    temp = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nThe list is empty.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">list</span>-&gt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_slist</span><span class="params">(list_type * <span class="built_in">list</span>, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> counter =<span class="number">0</span> ;</span><br><span class="line">    node_type *temp, *s;</span><br><span class="line">    temp = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">while</span>(counter &lt;i<span class="number">-1</span> &amp;&amp; temp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(counter != i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%d is invalid.\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertend_sllist</span><span class="params">(list_type *<span class="built_in">list</span>, node_type *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node_type *temp = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">while</span>( temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next = p;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_silist</span><span class="params">(list_type *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node_type *p;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">list</span>-&gt;head-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">list</span>-&gt;head-&gt;next;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;next = <span class="built_in">list</span>-&gt;head-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list_type l;</span><br><span class="line">    <span class="keyword">int</span> p, newdata;</span><br><span class="line">    node_type *newelement;</span><br><span class="line">    newelement = (node_type *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));</span><br><span class="line">    l.head = init_silist();</span><br><span class="line">    l.head-&gt;next = create_sllist(&amp;l);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The %d elemnent is:\n&quot;</span>, l.length);</span><br><span class="line">    print_sllist(&amp;l);</span><br><span class="line">    <span class="keyword">int</span> place[l.length+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//bug1  未给数组赋初值，导致数组自动附上未知值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nPlease enter a value.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;newdata);</span><br><span class="line">        newelement-&gt;data = newdata;</span><br><span class="line">        p = find_silist(&amp;l, newdata, place);</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>, length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(place[n] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n++;</span><br><span class="line">                length++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nThe data elememt before deletion is:&quot;</span>);</span><br><span class="line">            print_sllist(&amp;l);</span><br><span class="line">            <span class="keyword">int</span> i= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; length)&#123;</span><br><span class="line">                delete_slist(&amp;l, place[i]);</span><br><span class="line">                i++;</span><br><span class="line">                place[i] = place[i] - i;   <span class="comment">//bug2 删除一个元素后，重复元素的位置前移了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nThe data element  after deletion is:&quot;</span>);</span><br><span class="line">            print_sllist(&amp;l);</span><br><span class="line">        &#125;                            <span class="comment">//删除的问题！！！</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nThe data element before the insert is:&quot;</span>);</span><br><span class="line">            print_sllist(&amp;l);</span><br><span class="line">            insertend_sllist(&amp;l, newelement);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nThe data element  after the insert is:&quot;</span>);</span><br><span class="line">            print_sllist(&amp;l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free_silist(&amp;l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Ex2-3"><a href="#Ex2-3" class="headerlink" title="Ex2-3"></a>Ex2-3</h4><p>将两个按元素值递增有序的单链表，合并为一个按元素值递减有序的单链表，并分析算法的时空复杂度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;node_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    node_type *head;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;list_type;</span><br><span class="line"></span><br><span class="line"><span class="function">node_type *<span class="title">init_sllsit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node_type *head;</span><br><span class="line">    head = (node_type *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        head-&gt;data = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;init error.&quot;</span>);</span><br><span class="line">        head = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node_type *<span class="title">create_sllist</span><span class="params">(list_type *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, counter = <span class="number">0</span>;</span><br><span class="line">    node_type *h, *newnode, *temp;</span><br><span class="line">    h = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        h = (node_type *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));</span><br><span class="line">        <span class="keyword">if</span>(h != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            h-&gt;data = x;</span><br><span class="line">            h-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;length = counter;</span><br><span class="line">        <span class="keyword">return</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    temp = h;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        newnode = (node_type *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));</span><br><span class="line">        <span class="keyword">if</span>(newnode != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            newnode-&gt;data = x;</span><br><span class="line">            counter++;</span><br><span class="line">            temp-&gt;next = newnode;</span><br><span class="line">            temp = newnode;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = counter;</span><br><span class="line">    <span class="keyword">return</span>(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sllist</span><span class="params">(list_type *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node_type *temp;</span><br><span class="line">    temp = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThese %d records are:\n&quot;</span>, <span class="built_in">list</span>-&gt;length);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nThe list is empty.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">list</span>-&gt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sllist</span><span class="params">(list_type *<span class="built_in">list</span>, <span class="keyword">int</span> i, node_type *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    node_type * temp = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">while</span>(counter &lt; i<span class="number">-1</span> &amp;&amp; temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = p;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_sllist</span><span class="params">(list_type *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node_type *p;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">list</span>-&gt;head-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">list</span>-&gt;head-&gt;next;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;next = <span class="built_in">list</span>-&gt;head-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把链表2合并到1中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine_sllist</span><span class="params">(list_type *l1, list_type *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">1</span>;</span><br><span class="line">    node_type *temp;</span><br><span class="line">    node_type *head1 = l1-&gt;head, *head2 = l2-&gt;head;</span><br><span class="line">    <span class="keyword">while</span>(head2-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head1-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head2-&gt;next-&gt;data &lt; head1-&gt;next-&gt;data)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = (node_type*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));  </span><br><span class="line">                temp-&gt;data = head2-&gt;next-&gt;data;   </span><br><span class="line">                temp-&gt;next = <span class="literal">NULL</span>;          <span class="comment">//l2被改变主要bug</span></span><br><span class="line">                insert_sllist(l1, counter, temp);</span><br><span class="line">                <span class="comment">//counter++;                //插入失误主要bug</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head1 = head1-&gt;next;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head2-&gt;next-&gt;data &gt;= head1-&gt;data &amp;&amp; head1-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = (node_type*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));  </span><br><span class="line">            temp-&gt;data = head2-&gt;next-&gt;data;   </span><br><span class="line">            temp-&gt;next = <span class="literal">NULL</span>;  </span><br><span class="line">            insert_sllist(l1, counter, temp);</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">        head2 = head2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入链表l1，使之排序反转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invert_sllist</span><span class="params">(list_type *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node_type *last, *current, *cont;</span><br><span class="line">    last = <span class="literal">NULL</span>;</span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head-&gt;next;</span><br><span class="line">    cont = current;</span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cont = current-&gt;next;</span><br><span class="line">        current-&gt;next = last;</span><br><span class="line">        last = current;</span><br><span class="line">        current = cont;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//current = list-&gt;head; 无用代码，老师写错了？</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head-&gt;next = last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list_type l1, l2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the first sequence of incrementally ordered data ending in -1:\n&quot;</span>);</span><br><span class="line">    l1.head = init_sllsit();</span><br><span class="line">    l1.head-&gt;next = create_sllist(&amp;l1);</span><br><span class="line">    print_sllist(&amp;l1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPlease enter the second sequence of incrementally ordered data ending in -1:\n&quot;</span>);</span><br><span class="line">    l2.head = init_sllsit();</span><br><span class="line">    l2.head-&gt;next = create_sllist(&amp;l2);</span><br><span class="line">    print_sllist(&amp;l2);</span><br><span class="line"></span><br><span class="line">    combine_sllist(&amp;l1, &amp;l2);</span><br><span class="line">    print_sllist(&amp;l1);</span><br><span class="line">    invert_sllist(&amp;l1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThe list after transforming is:\n&quot;</span>);</span><br><span class="line">    print_sllist(&amp;l1);</span><br><span class="line">    free_sllist(&amp;l2);</span><br><span class="line">    free_sllist(&amp;l1);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将两个按元素值递增有序的单链表，合并为一个按元素值递减有序的单链表</span></span><br><span class="line"><span class="comment">并分析算法的时空复杂度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">答：程序时间复杂度为O(n^2);</span></span><br><span class="line"><span class="comment">       空间复杂度为O(1).</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Ex2-4"><a href="#Ex2-4" class="headerlink" title="Ex2-4"></a>Ex2-4</h4><p>用循环链表实现约瑟夫环，并分析算法的时空复杂度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;node_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    node_type *head;</span><br><span class="line">&#125;list_type;</span><br><span class="line"></span><br><span class="line"><span class="function">node_type *<span class="title">init_silist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node_type *head;</span><br><span class="line">    head = (node_type*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        head-&gt;data = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;init error.&quot;</span>);</span><br><span class="line">        head = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node_type *<span class="title">create_sllist</span><span class="params">(list_type *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the number ending with 0:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> x, counter = <span class="number">0</span>;</span><br><span class="line">    node_type *h, *newnode, *temp;</span><br><span class="line">    h = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        h = (node_type *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));</span><br><span class="line">        <span class="keyword">if</span>(h != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            h-&gt;data = x;</span><br><span class="line">            h-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;length = counter;</span><br><span class="line">        <span class="keyword">return</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    temp = h;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        newnode = (node_type *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));</span><br><span class="line">        <span class="keyword">if</span>(newnode != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            newnode-&gt;data = x;</span><br><span class="line">            counter++;</span><br><span class="line">            temp-&gt;next = newnode;</span><br><span class="line">            temp = newnode;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;          </span><br><span class="line">    <span class="built_in">list</span>-&gt;length = counter;</span><br><span class="line">    <span class="keyword">return</span>(h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void delete_slist(list_type * list, int i)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int counter = 0;</span></span><br><span class="line"><span class="comment">    node_type *temp, *s;</span></span><br><span class="line"><span class="comment">    temp = list-&gt;head;</span></span><br><span class="line"><span class="comment">    while(counter &lt;i-1 &amp;&amp; temp != NULL)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        temp = temp-&gt;next;</span></span><br><span class="line"><span class="comment">        counter++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    if(counter != i-1)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;\n%d is invalid.\n&quot;, i);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        s = temp-&gt;next;</span></span><br><span class="line"><span class="comment">        temp-&gt;next = temp-&gt;next-&gt;next;</span></span><br><span class="line"><span class="comment">        free(s);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    list-&gt;length--;</span></span><br><span class="line"><span class="comment">&#125;      </span></span><br><span class="line"><span class="comment">//删除函数待改</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//无需delete函数  太麻烦了。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list_type l;</span><br><span class="line">    l.head = init_silist();</span><br><span class="line">    node_type *p = l.head;</span><br><span class="line">    l.head-&gt;next = create_sllist(&amp;l);</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = l.head-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> n, i = <span class="number">0</span>;</span><br><span class="line">    node_type *temp = l.head;</span><br><span class="line">    node_type *s;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the number n:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(temp != temp-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i != n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;     <span class="comment">//找到需要删除的节点</span></span><br><span class="line">        s = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">        i = <span class="number">0</span>;    <span class="comment">//计数器重置</span></span><br><span class="line">        l.length--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The number of those who remain is:%d\n&quot;</span>, temp-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用循环链表实现约瑟夫环，并分析算法的时空复杂度。</span></span><br><span class="line"><span class="comment">答：空间复杂度为O(n^2).</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(1)-顺序表</title>
    <url>/2021/06/24/shujujiegou1/</url>
    <content><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>顺序表</p>
<hr>
<h3 id="实验及代码"><a href="#实验及代码" class="headerlink" title="实验及代码"></a>实验及代码</h3><h4 id="Ex1-1"><a href="#Ex1-1" class="headerlink" title="Ex1-1"></a>Ex1-1</h4><ul>
<li>首先创建一个顺序表：从键盘读入一组整数（长度小于等于20），按输入顺序放入顺序表，输入以-1结束（注意-1不放到顺序表内）；将创建好的顺序表元素依次输出到屏幕上;</li>
<li>在已创建好的顺序表中插入一个元素：从键盘读入需插入的元素值和插入位置，调用插入函数完成插入操作；然后将顺序表元素依次输出到屏幕上;</li>
<li>在已创建好的顺序表中删除一个元素：从键盘读入欲删除的元素位置（序号），调用删除函数完成删除操作；然后将顺序表元素依次输出到屏幕上;</li>
<li>算法用函数实现，主函数分别调用各算法；用数组和指针两种方法给顺序表元素分配存储空间。</li>
</ul>
<h5 id="静态内存分配-数组实现"><a href="#静态内存分配-数组实现" class="headerlink" title="静态内存分配-数组实现"></a>静态内存分配-数组实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNUM 21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MAXNUM];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; list_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createlist</span><span class="params">(list_type *lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, elem;</span><br><span class="line">    lp-&gt;length = <span class="number">0</span>; <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n please input data of the list\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;elem);</span><br><span class="line">        <span class="keyword">if</span> (elem == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        lp-&gt;data[i] = elem;</span><br><span class="line">        lp-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlist</span><span class="params">(list_type *lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThese %d records are:\n&quot;</span>, lp-&gt;length);</span><br><span class="line">    <span class="keyword">if</span> (lp-&gt;length &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This list is empty!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lp-&gt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, lp-&gt;data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nlength of the list is : %d&quot;</span>, lp-&gt;length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertlist</span><span class="params">(list_type *lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newelem, n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPlease enter the number to insert and its position.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;newelem, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (lp-&gt;length &gt;= MAXNUM)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The list is full.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span> || n &gt; lp-&gt;length + <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is invalid value&quot;</span>,n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lp-&gt;length - <span class="number">1</span>; i &gt;= n - <span class="number">1</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                lp-&gt;data[i + <span class="number">1</span>] = lp-&gt;data[i];</span><br><span class="line">            &#125;</span><br><span class="line">            lp-&gt;data[n - <span class="number">1</span>] = newelem;</span><br><span class="line">            lp-&gt;length = lp-&gt;length + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletelist</span><span class="params">(list_type *lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPlease enter the position of the number to be deleted.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (lp-&gt;length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The list id empty.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span> || n &gt; lp-&gt;length)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is a invalid value&quot;</span>,n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; lp-&gt;length; i++)</span><br><span class="line">                lp-&gt;data[i - <span class="number">1</span>] = lp-&gt;data[i];</span><br><span class="line">            lp-&gt;length = lp-&gt;length - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    list_type <span class="built_in">list</span>;</span><br><span class="line">    createlist(&amp;<span class="built_in">list</span>);</span><br><span class="line">    printlist(&amp;<span class="built_in">list</span>); <span class="comment">// 1)</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nPlease select operation：\</span></span><br><span class="line"><span class="string">            1 is for inserting a element,\</span></span><br><span class="line"><span class="string">            2is for deleting a element.\n &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="keyword">switch</span>(a)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            insertlist(&amp;<span class="built_in">list</span>);</span><br><span class="line">            printlist(&amp;<span class="built_in">list</span>);</span><br><span class="line">            <span class="keyword">break</span>;             <span class="comment">// 2)</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            deletelist(&amp;<span class="built_in">list</span>);</span><br><span class="line">            printlist(&amp;<span class="built_in">list</span>);</span><br><span class="line">            <span class="keyword">break</span>;             <span class="comment">// 3)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="动态内存分配-指针实现"><a href="#动态内存分配-指针实现" class="headerlink" title="动态内存分配-指针实现"></a>动态内存分配-指针实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNUM 21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;list_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createlist</span><span class="params">(list_type *lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    lp-&gt;p= (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(MAXNUM*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));       <span class="comment">//?</span></span><br><span class="line">    lp-&gt;length=<span class="number">0</span>;   <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n please input data of the list\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;elem);</span><br><span class="line">        <span class="keyword">if</span>(elem==<span class="number">-1</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        lp-&gt;p[i]= elem;     <span class="comment">//也可以用数组的形式赋值</span></span><br><span class="line">        lp-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlist</span><span class="params">(list_type *lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThese %d records are:\n&quot;</span>, lp-&gt;length);</span><br><span class="line">    <span class="keyword">if</span> (lp-&gt;length &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This list is empty!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lp-&gt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, lp-&gt;p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nlength of the list is : %d&quot;</span>, lp-&gt;length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertlist</span><span class="params">(list_type *lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newelem, n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPlease enter the number to insert and its position.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;newelem, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (lp-&gt;length &gt;= MAXNUM)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The list is full.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span> || n &gt; lp-&gt;length + <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;n is invalid value&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n == lp-&gt;length)</span><br><span class="line">            &#123;</span><br><span class="line">                *(lp-&gt;p+lp-&gt;length) = newelem;</span><br><span class="line">                lp-&gt;length++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;        <span class="comment">//insert last one</span></span><br><span class="line">            <span class="keyword">int</span> * a = &amp;(lp-&gt;p[n]);</span><br><span class="line">            <span class="keyword">int</span> * b = &amp;(lp-&gt;p[lp-&gt;length]);</span><br><span class="line">            <span class="keyword">for</span>( ; b&gt;a; b-- )</span><br><span class="line">            &#123;</span><br><span class="line">                *b = *(b<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            *b = newelem;</span><br><span class="line">            lp-&gt;length++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletelist</span><span class="params">(list_type *lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPlease enter the position of the number to be deleted.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (lp-&gt;length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The list id empty.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span> || n &gt; lp-&gt;length)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;n is a invalid value&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> *a = lp-&gt;p + lp-&gt;length;</span><br><span class="line">            <span class="keyword">int</span> *b = &amp;(lp-&gt;p[n]);</span><br><span class="line">            <span class="keyword">for</span>( ; b&lt;a; b++)</span><br><span class="line">            &#123;</span><br><span class="line">                *(b)=*(b+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            lp-&gt;length--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list_type <span class="built_in">list</span>;</span><br><span class="line">    createlist(&amp;<span class="built_in">list</span>);</span><br><span class="line">    printlist(&amp;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//insert</span></span><br><span class="line">    insertlist(&amp;<span class="built_in">list</span>);</span><br><span class="line">    printlist(&amp;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete</span></span><br><span class="line">    deletelist(&amp;<span class="built_in">list</span>);</span><br><span class="line">    printlist(&amp;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>.p);</span><br><span class="line">    getchar(); </span><br><span class="line">    getchar(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Ex1-2"><a href="#Ex1-2" class="headerlink" title="Ex1-2"></a>Ex1-2</h4><p>设线性表存放在向量A[1,2,…,MAXNUM]的前elenum个分量中，且递增有序。请写一个算法，将x插入到线性表的适当位置上，以保持线性表的有序性（用顺序表实现）。注意该题中没有提供插入元素的具体位置，要根据元素值大小寻找合适的位置。要求分析算法的时间和空间复杂度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNUM 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MAXNUM];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;list_type; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createlist</span><span class="params">(list_type *lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, elem;</span><br><span class="line">    lp-&gt;length = <span class="number">0</span>; <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n please input data of the list\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; MAXNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;elem);</span><br><span class="line">        <span class="keyword">if</span> (elem == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        lp-&gt;data[i] = elem;</span><br><span class="line">        lp-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortlist</span><span class="params">(list_type *lp)</span>   <span class="comment">//冒泡排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; lp-&gt;length<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=lp-&gt;length<span class="number">-1</span>; j &gt; i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="keyword">if</span>(lp-&gt;data[j<span class="number">-1</span>] &gt; lp-&gt;data[j])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = lp-&gt;data[j<span class="number">-1</span>];</span><br><span class="line">                lp-&gt;data[j<span class="number">-1</span>] = lp-&gt;data[j];</span><br><span class="line">                lp-&gt;data[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertlist</span><span class="params">(list_type * lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lp-&gt;length &gt;= MAXNUM)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nThe list is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> newelem, flag=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPlease enter the new element.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;newelem);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; lp-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lp-&gt;data[i] &gt; newelem)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=lp-&gt;length; j&gt;i; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                lp-&gt;data[j] = lp-&gt;data[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            lp-&gt;data[i] = newelem;</span><br><span class="line">            lp-&gt;length++;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        lp-&gt;data[lp-&gt;length]=newelem;</span><br><span class="line">        lp-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlist</span><span class="params">(list_type *lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThese %d records are:\n&quot;</span>, lp-&gt;length);</span><br><span class="line">    <span class="keyword">if</span> (lp-&gt;length &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This list is empty!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lp-&gt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, lp-&gt;data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nlength of the list is : %d \n&quot;</span>, lp-&gt;length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list_type <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create</span></span><br><span class="line">    createlist(&amp;<span class="built_in">list</span>);</span><br><span class="line">    sortlist(&amp;<span class="built_in">list</span>);</span><br><span class="line">    printlist(&amp;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        insertlist(&amp;<span class="built_in">list</span>);</span><br><span class="line">        printlist(&amp;<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-总</title>
    <url>/2021/06/24/shujujiegou/</url>
    <content><![CDATA[<h3 id="关于本模块"><a href="#关于本模块" class="headerlink" title="关于本模块"></a>关于本模块</h3><p>数据结构是我大二上学期的一门专业必修课，本课程是基于c语言的数据结构算法实现。在此模块里，汇总了整个课程所写的所有上机实验代码，如果你是初学者，相信看完这个对于c语言指针的使用将不再是问题。本课程使用的参考教材为：《数据结构与算法-c语言》(传智播客)，《数据结构（c语言版）》(严蔚敏)。</p>
<p>本模块分为以下五部分内容：</p>
<ul>
<li>实验一：顺序表 ———– <a href="https://eatard.gitee.io/2021/06/24/shujujiegou2/">实验一</a></li>
<li>实验二：链表 ————– <a href="https://eatard.gitee.io/2021/06/24/shujujiegou2/">实验二</a></li>
<li>实验三：栈和队列 ——– <a href="https://eatard.gitee.io/2021/06/24/shujujiegou2/">实验三</a></li>
<li>实验四：二叉树 ———– <a href="https://eatard.gitee.io/2021/06/24/shujujiegou2/">实验四</a></li>
<li>实验五：查找和排序 —– <a href="https://eatard.gitee.io/2021/06/24/shujujiegou2/">实验五</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(5)-查找排序</title>
    <url>/2021/06/28/shujujiegou5/</url>
    <content><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>查找排序算法</p>
<hr>
<h3 id="实验及代码"><a href="#实验及代码" class="headerlink" title="实验及代码"></a>实验及代码</h3><h4 id="Ex5-1"><a href="#Ex5-1" class="headerlink" title="Ex5-1"></a>Ex5-1</h4><p>设有序序列的数据元素为：<code>（3，10，13，17，40，43，50，70）</code></p>
<ul>
<li>编写顺序查找函数;</li>
<li>编写二分查找函数;</li>
<li>乱序输入元素，编写创建二叉排序树函数和查找函数;</li>
<li>在主程序中输入关键字（例如43和5），分别调用三种查找函数，输出结果。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    BTnode *Rchild;</span><br><span class="line">    BTnode *Lchild;</span><br><span class="line">&#125;Btree_node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树数据结构类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Btree_node *root;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;Btree_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num[M];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;num_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_Sort</span><span class="params">(num_type *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; p-&gt;length<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; p-&gt;length<span class="number">-1</span>-i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;num[j] &gt; p-&gt;num[j+<span class="number">1</span>])     <span class="comment">//相邻两元素比较</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = p-&gt;num[j];       <span class="comment">//交换元素</span></span><br><span class="line">                p-&gt;num[j] = p-&gt;num[j+<span class="number">1</span>];</span><br><span class="line">                p-&gt;num[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seq_search</span><span class="params">(num_type *p, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; p-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;num[i] == key)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找  返回key的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(num_type *p, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bubble_Sort(p);</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = p-&gt;length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;num[mid] &gt; key)</span><br><span class="line">            high = mid <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;num[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;num[mid] &lt; key) </span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;             </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(num_type *p, Btree_type *bst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Btree_node *b, *temp;</span><br><span class="line">    bst-&gt;num = p-&gt;length;</span><br><span class="line">    bst-&gt;root = (Btree_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Btree_node));</span><br><span class="line">    bst-&gt;root-&gt;data = p-&gt;num[<span class="number">0</span>];</span><br><span class="line">    bst-&gt;root-&gt;Rchild = <span class="literal">NULL</span>;</span><br><span class="line">    bst-&gt;root-&gt;Lchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//temp = (Btree_node *)malloc(sizeof(Btree_node));</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; p-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b = (Btree_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Btree_node));</span><br><span class="line">        b-&gt;data = p-&gt;num[i];</span><br><span class="line">        b-&gt;Lchild = <span class="literal">NULL</span>;</span><br><span class="line">        b-&gt;Rchild = <span class="literal">NULL</span>;</span><br><span class="line">        temp = bst-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;data &lt; b-&gt;data)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;Rchild == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp-&gt;Rchild = b;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> temp = temp-&gt;Rchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;Lchild == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp-&gt;Lchild = b;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> temp = temp-&gt;Lchild;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//free(temp);  // 不需要</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树查找</span></span><br><span class="line"><span class="function">Btree_node* <span class="title">BST_search</span><span class="params">(Btree_node *r, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(key == r-&gt;data) <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; r-&gt;data) <span class="keyword">return</span>(BST_search(r-&gt;Lchild, key));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (BST_search(r-&gt;Rchild, key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_btree</span><span class="params">(Btree_node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;Lchild != <span class="literal">NULL</span>) destroy_btree(root-&gt;Lchild);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;Rchild != <span class="literal">NULL</span>) destroy_btree(root-&gt;Rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num_type n, key;</span><br><span class="line">    n.length = <span class="number">0</span>;</span><br><span class="line">    key.length =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x, k;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the element ending with -1\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n.num[n.length] = x;</span><br><span class="line">        n.length++;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the key value ending with -1\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span>(k != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        key.num[key.length] = k;</span><br><span class="line">        key.length++;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//建立二叉排序树</span></span><br><span class="line">    Btree_type btr;</span><br><span class="line">    btr.num = <span class="number">0</span>;</span><br><span class="line">    btr.root = <span class="literal">NULL</span>;</span><br><span class="line">    BST(&amp;n, &amp;btr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; key.length; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//二分查找</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The result of binary search:     &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> place1 = binary_search(&amp;n, key.num[i]);</span><br><span class="line">        <span class="keyword">if</span>(place1 &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d doesn`t exist\n&quot;</span>, key.num[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;The position of %d in the array is %d\n&quot;</span>, key.num[i], place1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//顺序查找</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The result of sequence search:   &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> place2 = seq_search(&amp;n, key.num[i]);</span><br><span class="line">        <span class="keyword">if</span>(place2 &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d doesn`t exist\n&quot;</span>, key.num[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;The position of %d in the array is %d\n&quot;</span>, key.num[i], place2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二叉树查找</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The result of BST search:        &quot;</span>);</span><br><span class="line">        Btree_node* place3 = BST_search(btr.root, key.num[i]);</span><br><span class="line">        <span class="keyword">if</span>(place3 == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d doesn`t exist\n&quot;</span>, key.num[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d  exists\n&quot;</span>, place3-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    destroy_btree(btr.root);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Ex5-2"><a href="#Ex5-2" class="headerlink" title="Ex5-2"></a>Ex5-2</h4><ul>
<li>编写简单选择法函数;</li>
<li>编写直接插入法函数;</li>
<li>编写冒泡法排序函数;</li>
<li>编写快速排序函数;</li>
<li>在主程序中输入一组数据元素（例如：513，87，512，61，908，170，897，275，653，462），分别调用三种排序函数，输出每趟排序结果。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">num</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num[M];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;num_type;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_Sort</span><span class="params">(num_type *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; p-&gt;length<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; p-&gt;length<span class="number">-1</span>-i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;num[j] &gt; p-&gt;num[j+<span class="number">1</span>])     <span class="comment">//相邻两元素比较</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = p-&gt;num[j];       <span class="comment">//交换元素</span></span><br><span class="line">                p-&gt;num[j] = p-&gt;num[j+<span class="number">1</span>];</span><br><span class="line">                p-&gt;num[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Selection_sort</span><span class="params">(num_type *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min, nummin;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; p-&gt;length<span class="number">-1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        nummin = p-&gt;num[j];</span><br><span class="line">        min = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=j; i &lt; p-&gt;length<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(p-&gt;num[i+<span class="number">1</span>] &lt; nummin)</span><br><span class="line">            &#123;</span><br><span class="line">                min = i+<span class="number">1</span>;             <span class="comment">//找出最小值的位置</span></span><br><span class="line">                nummin = p-&gt;num[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = p-&gt;num[min];      <span class="comment">//交换最小值和第一个元素的位置</span></span><br><span class="line">        p-&gt;num[min] = p-&gt;num[j];</span><br><span class="line">        p-&gt;num[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insertion_Sort</span><span class="params">(num_type *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=p-&gt;length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;num[i] &lt; p-&gt;num[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = p-&gt;num[i];</span><br><span class="line">                p-&gt;num[i] = p-&gt;num[j];</span><br><span class="line">                p-&gt;num[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick</span><span class="params">(<span class="keyword">int</span> num[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> low = start;</span><br><span class="line">        <span class="keyword">int</span> high = end;</span><br><span class="line">        <span class="comment">//快排分区操作</span></span><br><span class="line">        <span class="keyword">int</span> temp = num[low];     <span class="comment">//取第一位为基准</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)       <span class="comment">//相等时分区操作完成</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; num[high] &gt; temp)    <span class="comment">//遍历找到比temp小的       </span></span><br><span class="line">                high--;</span><br><span class="line">            <span class="keyword">if</span>(low &gt; high) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                num[low] = num[high];</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; num[low] &lt; temp)</span><br><span class="line">                low++;</span><br><span class="line">            <span class="keyword">if</span>(low &gt; high) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num[high] = num[low];</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        num[low] = temp;</span><br><span class="line">        Quick(num, start, low<span class="number">-1</span>);</span><br><span class="line">        Quick(num, low+<span class="number">1</span>, end);    <span class="comment">//递归实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(num_type *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Quick(p-&gt;num, <span class="number">0</span>, p-&gt;length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_num</span><span class="params">(num_type *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; p-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num_type s1, s2, s3, s4;</span><br><span class="line">    s1.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x, i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the element ending with 0\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s1.num[i] = x;</span><br><span class="line">        s2.num[i] = x;</span><br><span class="line">        s3.num[i] = x;</span><br><span class="line">        s4.num[i] = x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        s1.length++;</span><br><span class="line">        s2.length = s1.length;</span><br><span class="line">        s3.length = s1.length;</span><br><span class="line">        s4.length = s1.length;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    Selection_sort(&amp;s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;选择排序的结果：&quot;</span>);</span><br><span class="line">    print_num(&amp;s1);</span><br><span class="line">    Insertion_Sort(&amp;s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入排序的结果：&quot;</span>);</span><br><span class="line">    print_num(&amp;s2);</span><br><span class="line">    Bubble_Sort(&amp;s3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;冒泡排序的结果：&quot;</span>);</span><br><span class="line">    print_num(&amp;s3);</span><br><span class="line">    Quick_Sort(&amp;s4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;快速排序的结果：&quot;</span>);</span><br><span class="line">    print_num(&amp;s4);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(3)-栈和队列</title>
    <url>/2021/06/26/shujujiegou3/</url>
    <content><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>栈和队列</p>
<hr>
<h3 id="实验及代码"><a href="#实验及代码" class="headerlink" title="实验及代码"></a>实验及代码</h3><h4 id="Ex3-1"><a href="#Ex3-1" class="headerlink" title="Ex3-1"></a>Ex3-1</h4><ul>
<li>链栈结点类型定义为：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span>  data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;node_type;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写进栈函数push;</li>
<li>编写出栈函数pop</li>
<li>编写main函数，首先建立一空链栈；调用进栈函数，将从键盘输入的数据元素逐个进栈，输入0结束；显示进栈后的数据元素；调用两次出栈函数，显示出栈后的数据元素。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;node_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    node_type *top;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;stack_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push_stack</span><span class="params">(stack_type * lp, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node_type *p;</span><br><span class="line">    p = (node_type *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node_type));</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;data = x;</span><br><span class="line">        p-&gt;next = lp-&gt;top;</span><br><span class="line">        lp-&gt;top = p;</span><br><span class="line">        lp-&gt;length++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop_stack</span><span class="params">(stack_type *lp, <span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node_type *p;</span><br><span class="line">    <span class="keyword">if</span>(lp-&gt;top == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;stack is underflow&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *x = lp-&gt;top-&gt;data;</span><br><span class="line">        p = lp-&gt;top;</span><br><span class="line">        lp-&gt;top = lp-&gt;top-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        lp-&gt;length--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//置空栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean_stack</span><span class="params">(stack_type *lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node_type *temp;</span><br><span class="line">    <span class="keyword">while</span>(lp-&gt;top != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = lp-&gt;top;</span><br><span class="line">        lp-&gt;top = lp-&gt;top-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    lp-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stack</span><span class="params">(stack_type *lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node_type *temp;</span><br><span class="line">    temp = lp-&gt;top;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThe element in the stack is: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(lp-&gt;top == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nThe stack is empty&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, temp-&gt;data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack_type ls;</span><br><span class="line">    ls.length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ls.top = (node_type *)malloc(sizeof(node_type));</span></span><br><span class="line">    ls.top = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> newdata;</span><br><span class="line">    <span class="keyword">int</span> *output = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));      <span class="comment">//入栈和出栈元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the data end with 0:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;newdata);</span><br><span class="line">    <span class="keyword">while</span>(newdata &gt; <span class="number">0</span>)      <span class="comment">//这样就不能输入值0？</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(push_stack(&amp;ls, newdata) == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;newdata);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nThe error pushing stack\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print_stack(&amp;ls);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pop_stack(&amp;ls, output) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nThe element that comes out of stack is: %d&quot;</span>, *output);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\nThe error poping stack.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print_stack(&amp;ls);</span><br><span class="line">    clean_stack(&amp;ls);</span><br><span class="line">    <span class="built_in">free</span>(output);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ex3_1：链栈 </span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Ex3-2"><a href="#Ex3-2" class="headerlink" title="Ex3-2"></a>Ex3-2</h4><ul>
<li>顺序循环队列类型定义为：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span>     </span><br><span class="line"><span class="keyword">int</span> data[N];</span><br><span class="line"><span class="keyword">int</span> front, rear;</span><br><span class="line">&#125;queue_type;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写循环队列出队函数dequeue;</li>
<li>编写循环队列入队函数enqueue;</li>
<li>编写函数：<code>void aa(queue_type *q)</code>调用出队函数把队列q中的元素一一出队列，如果是负数直接抛弃；如果是正数，则调用入队函数，插入到q的队尾。</li>
<li>编写main函数，首先建立一个队列，其中的数据元素举例{2, 3, -4, 6, -5, 8, -9, 7, -10, 20}；然后调用aa函数，将aa函数调用前后队列的数据元素分别输出到屏幕上。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">int</span> data[N];</span><br><span class="line">     <span class="keyword">int</span> front;</span><br><span class="line">     <span class="keyword">int</span> rear;</span><br><span class="line">&#125;queue_type;</span><br><span class="line"><span class="comment">//约定：data[0]不存放元素，front指示对头元素的前一个位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//出队函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enqueue</span><span class="params">(queue_type *q, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>((q-&gt;rear+<span class="number">1</span>) % N == q-&gt;front)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          q-&gt;rear = (q-&gt;rear+<span class="number">1</span>) % N;   <span class="comment">//移rear</span></span><br><span class="line">          q-&gt;data[q-&gt;rear] = x;        <span class="comment">//新元素入队尾</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">(queue_type *q, <span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(q-&gt;rear == q-&gt;front)   <span class="comment">//判断队列是否为空</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;queue is empty&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          q-&gt;front = (q-&gt;front+<span class="number">1</span>) % N;  <span class="comment">//移动front;</span></span><br><span class="line">          *x = q-&gt;data[q-&gt;front];     <span class="comment">//front不存储元素 ，所以先移动再取值</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aa</span><span class="params">(queue_type *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> length = q-&gt;rear;</span><br><span class="line">     <span class="keyword">int</span> *output = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">     <span class="keyword">while</span>(length != <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span>(dequeue(q, output))</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="keyword">if</span>(*output &gt; <span class="number">0</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="keyword">if</span>(enqueue(q, *output) == <span class="number">0</span>)</span><br><span class="line">                         <span class="built_in">printf</span>(<span class="string">&quot;\nenqueue error\n&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\ndequeue error\n&quot;</span>);</span><br><span class="line">          length--;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">free</span>(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_queue</span><span class="params">(queue_type *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\nThe data in the queue are: &quot;</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=q-&gt;front+<span class="number">1</span>; i&lt;=q-&gt;rear; i++)</span><br><span class="line">     &#123; </span><br><span class="line">          i = i % N;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q-&gt;data[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     queue_type lq;</span><br><span class="line">     lq.data[<span class="number">0</span>]=<span class="number">0</span>;lq.data[<span class="number">1</span>]=<span class="number">2</span>;lq.data[<span class="number">2</span>]=<span class="number">3</span>;lq.data[<span class="number">3</span>]=<span class="number">-1</span>;lq.data[<span class="number">4</span>]=<span class="number">6</span>;</span><br><span class="line">     lq.data[<span class="number">5</span>]=<span class="number">-5</span>;lq.data[<span class="number">6</span>]=<span class="number">8</span>;lq.data[<span class="number">7</span>]=<span class="number">-9</span>;lq.data[<span class="number">8</span>]=<span class="number">7</span>;lq.data[<span class="number">9</span>]=<span class="number">-10</span>;lq.data[<span class="number">10</span>]=<span class="number">20</span>;</span><br><span class="line">     lq.front = <span class="number">0</span>;</span><br><span class="line">     lq.rear = <span class="number">10</span>;</span><br><span class="line">     print_queue(&amp;lq);</span><br><span class="line">     aa(&amp;lq);</span><br><span class="line">     print_queue(&amp;lq);</span><br><span class="line">     getchar();</span><br><span class="line">     getchar();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ex3_2：循环队列 </span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Ex3-3"><a href="#Ex3-3" class="headerlink" title="Ex3-3"></a>Ex3-3</h4><p>设2个栈共占一维数组空间S[m],它们的栈底分别在数组的两端，且进栈的每个数据元素只占用一个分量。请编写两个栈公共的栈操作算法，取栈顶元素get(i), i=0或1分别表示不同的栈号（需要自己设计数据结构）。对两个栈分别入/出栈，并打印显示两个栈在算法操作前后各自的数据元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 30</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[M];</span><br><span class="line">    <span class="keyword">int</span> top1, top2;</span><br><span class="line">&#125;stack_type;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取栈顶元素，i为1或2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(stack_type *ls, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">if</span>(ls-&gt;top1 &gt;= <span class="number">0</span> || ls-&gt;top2 &lt;= M<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; ls-&gt;top1 &gt;= <span class="number">0</span>)</span><br><span class="line">            x = ls-&gt;data[ls-&gt;top1];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The first stack is empty.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">2</span> &amp;&amp; ls-&gt;top2 &lt;= M<span class="number">-1</span>)</span><br><span class="line">            x = ls-&gt;data[ls-&gt;top2];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The second stack is empty.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The stack is empty.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(stack_type *ls, <span class="keyword">int</span> i)</span>   <span class="comment">//i为1或2，表示对哪个栈操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the element :\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(ls-&gt;top1 == ls-&gt;top2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The stack is full.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ls-&gt;top1 = ls-&gt;top1 + <span class="number">1</span>;</span><br><span class="line">            ls-&gt;data[ls-&gt;top1] = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ls-&gt;top2 = ls-&gt;top2 - <span class="number">1</span>;</span><br><span class="line">            ls-&gt;data[ls-&gt;top2] = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">pop</span><span class="params">(stack_type *ls, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *out;</span><br><span class="line">    <span class="keyword">if</span>(ls-&gt;top1 &gt;= <span class="number">0</span> || ls-&gt;top2 &lt;= M<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; ls-&gt;top1 &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            out = &amp;(ls-&gt;data[ls-&gt;top1]);</span><br><span class="line">            ls-&gt;top1 = ls-&gt;top1 - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; ls-&gt;top1 &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The first stack is empty.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">2</span> &amp;&amp; ls-&gt;top2 &lt;= M<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            out = &amp;(ls-&gt;data[ls-&gt;top2]);</span><br><span class="line">            ls-&gt;top2 = ls-&gt;top2 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">2</span> &amp;&amp; ls-&gt;top2 &gt; M<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The second stack is empty.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Both of the two stacks are empty.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stack</span><span class="params">(stack_type *ls, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The element in the stack %d is:&quot;</span>, i);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(temp = ls-&gt;top1; temp &gt;= <span class="number">0</span>; temp--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ls-&gt;data[temp]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(temp = ls-&gt;top2; temp &lt; M; temp++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ls-&gt;data[temp]);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack_type ls;</span><br><span class="line">    ls.top1 = <span class="number">-1</span>;</span><br><span class="line">    ls.top2 = M;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please choose the operation:1 for pushing, 2 for poping, 3 for taking the top element of the stack, 0 for ending:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">    <span class="keyword">int</span> *x = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">while</span>(c &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please enter the number of the stack:\n&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">            <span class="keyword">if</span>(push(&amp;ls, n));</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;push error\n&quot;</span>);</span><br><span class="line">            print_stack(&amp;ls, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please enter the number of the stack:\n&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">            x = pop(&amp;ls, i);</span><br><span class="line">            <span class="keyword">if</span>(x != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;The poping element of the stack%d is:%d\n&quot;</span>, i, *x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;pop error\n&quot;</span>);</span><br><span class="line">            print_stack(&amp;ls, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please enter the number of the stack:\n&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;j);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The top element of the stack%d is: %d\n&quot;</span>, j, get(&amp;ls, j));</span><br><span class="line">            print_stack(&amp;ls, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please choose the operation:1 for pushing, 2 for poping, 3 for taking the top element of the stack, 0 for ending:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Ex3-4"><a href="#Ex3-4" class="headerlink" title="Ex3-4"></a>Ex3-4</h4><p>假设一维数组Sq[m]存储循环队列的元素，若要使m个存储空间全部都得到利用，需要设置一个标志tag，tag=0或1来区分队首和队尾指针相同时队列是空还是满。请编写此结构对应的出、入队算法（需要自己设计数据结构），并打印显示队列在执行算法前后的数据元素，进行对比。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Sq[M];</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">&#125;queue_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(queue_type *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;front = <span class="number">0</span>;</span><br><span class="line">    p-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    p-&gt;tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_queue</span><span class="params">(queue_type *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;tag == <span class="number">0</span> &amp;&amp; q-&gt;front == q-&gt;rear)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The queue is empty&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(q-&gt;tag == <span class="number">1</span> &amp;&amp; q-&gt;front == q-&gt;rear)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The queue is full.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The data in the queue are: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=q-&gt;front+<span class="number">1</span>; i&lt;=q-&gt;rear; i++)</span><br><span class="line">        &#123; </span><br><span class="line">            i = i % M;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q-&gt;Sq[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enqueue</span><span class="params">(queue_type *q, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;tag == <span class="number">1</span> &amp;&amp; q-&gt;front == q-&gt;rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The queue is full.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;rear = (q-&gt;rear+<span class="number">1</span>) % M;</span><br><span class="line">        q-&gt;Sq[q-&gt;rear] = x;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;front == q-&gt;rear)</span><br><span class="line">            q-&gt;tag = <span class="number">1</span>;           <span class="comment">//标志队满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">(queue_type *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;tag == <span class="number">0</span> &amp;&amp; q-&gt;front == q-&gt;rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The queue is empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;front = (q-&gt;front+<span class="number">1</span>) % M;</span><br><span class="line">        <span class="comment">//*x = q-&gt;Sq[q-&gt;front];</span></span><br><span class="line">        <span class="keyword">if</span>(q-&gt;front == q-&gt;rear)</span><br><span class="line">            q-&gt;tag = <span class="number">0</span>;       <span class="comment">//标志队空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue_type q;</span><br><span class="line">    init(&amp;q);</span><br><span class="line">    <span class="keyword">int</span> x, c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the element end with 0:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        enqueue(&amp;q, x);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    print_queue(&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please choose the operation:1: enqueue  2:dequeue\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please enter the element:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            enqueue(&amp;q, x);</span><br><span class="line">            print_queue(&amp;q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dequeue(&amp;q);</span><br><span class="line">            print_queue(&amp;q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;illegal input\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(4)-二叉树</title>
    <url>/2021/06/27/shujujiegou4/</url>
    <content><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>栈和队列</p>
<hr>
<h3 id="实验及代码"><a href="#实验及代码" class="headerlink" title="实验及代码"></a>实验及代码</h3><h4 id="Ex4-1"><a href="#Ex4-1" class="headerlink" title="Ex4-1"></a>Ex4-1</h4><ul>
<li>二叉树结点类型定义为：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bnode</span></span></span><br><span class="line"><span class="class">&#123;</span>  <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bnode</span> *<span class="title">lc</span>, *<span class="title">rc</span>;</span></span><br><span class="line">&#125;bnode_type;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>输入带*（表示空指针）的序列，以先序框架创建二叉树；</li>
<li>编写中序遍历函数;</li>
<li>编写后序遍历函数；</li>
<li>编写函数fd求二叉树的深度；</li>
<li>编写main( )函数，先调用创建函数，建立一颗二叉树；然后分别调用中序、后序遍历函数，将二叉树的中序和后序遍历序列输出到屏幕上；最后调用fd函数，求出深度，并显示到屏幕上。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">btreenode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">btreenode</span> *<span class="title">lc</span>,*<span class="title">rc</span>;</span></span><br><span class="line">&#125;btreenode_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    btreenode_type *root;</span><br><span class="line">    <span class="keyword">int</span> num; </span><br><span class="line">&#125;BTree_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_recursion</span><span class="params">(btreenode_type *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    btreenode_type *p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;x);</span><br><span class="line">    p = (btreenode_type*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(btreenode_type));</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        p-&gt;data = x;</span><br><span class="line">    root-&gt;lc = p;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lc != <span class="literal">NULL</span>)</span><br><span class="line">        create_recursion(root-&gt;lc);   <span class="comment">//进行下一次递归</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;x);</span><br><span class="line">    p = (btreenode_type*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(btreenode_type));</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">        p-&gt;data = x;</span><br><span class="line">    root-&gt;rc = p;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;rc != <span class="literal">NULL</span>)            <span class="comment">//进行下一次递归</span></span><br><span class="line">        create_recursion(root-&gt;rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_btree</span><span class="params">(BTree_type * BT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the elements(先序),empty node indicated by *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;x);</span><br><span class="line">    BT-&gt;root = (btreenode_type *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(btreenode_type));</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BT-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BT-&gt;root-&gt;data = x;</span><br><span class="line">    BT-&gt;root-&gt;lc = <span class="literal">NULL</span>;</span><br><span class="line">    BT-&gt;root-&gt;rc = <span class="literal">NULL</span>; </span><br><span class="line">    create_recursion(BT-&gt;root);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_traversal</span><span class="params">(btreenode_type *bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bt-&gt;lc != <span class="literal">NULL</span>) inorder_traversal(bt-&gt;lc);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, bt-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(bt-&gt;rc != <span class="literal">NULL</span>) inorder_traversal(bt-&gt;rc);  <span class="comment">//这三行的顺序决定了遍历顺序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder_traversal</span><span class="params">(btreenode_type *bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bt-&gt;lc != <span class="literal">NULL</span>) postorder_traversal(bt-&gt;lc);</span><br><span class="line">        <span class="keyword">if</span>(bt-&gt;rc != <span class="literal">NULL</span>) postorder_traversal(bt-&gt;rc);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, bt-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值为depth 递归求解</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fd_recursion</span><span class="params">(btreenode_type *r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> h1 = fd_recursion(r-&gt;lc);</span><br><span class="line">        <span class="keyword">int</span> h2 = fd_recursion(r-&gt;rc);</span><br><span class="line">        <span class="keyword">if</span>(h1 &gt; h2) <span class="keyword">return</span> h1+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> h2+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_btree</span><span class="params">(btreenode_type *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lc != <span class="literal">NULL</span>) destroy_btree(root-&gt;lc);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;rc != <span class="literal">NULL</span>) destroy_btree(root-&gt;rc);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTree_type bt;</span><br><span class="line">    bt.num = <span class="number">0</span>;</span><br><span class="line">    create_btree(&amp;bt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The middle order sequence is:   &quot;</span>);</span><br><span class="line">    inorder_traversal(bt.root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The post-order sequence is:     &quot;</span>);</span><br><span class="line">    postorder_traversal(bt.root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The height of this binary tree is%d\n&quot;</span>,fd_recursion(bt.root));</span><br><span class="line">    destroy_btree(bt.root);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Ex4-2"><a href="#Ex4-2" class="headerlink" title="Ex4-2"></a>Ex4-2</h4><ul>
<li>输入一组整数（权值），编写算法建立哈夫曼树;</li>
<li>以先序遍历为框架，输出每个权值对应的二进制编码。<br>注：此题好像我当初对于题目理解有问题，做的不太对，慎参。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有问题</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    BTnode *Lchild, *Rchild;</span><br><span class="line">&#125;Btree_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    Btree_node *root;</span><br><span class="line">&#125;Btree_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> data[M];</span><br><span class="line">&#125;num_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_weightnum</span><span class="params">(num_type *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the weight ending with 0\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n-&gt;data[n-&gt;length] = x;</span><br><span class="line">        n-&gt;length++;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_Sort</span><span class="params">(num_type *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; p-&gt;length<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; p-&gt;length<span class="number">-1</span>-i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data[j] &gt; p-&gt;data[j+<span class="number">1</span>])     <span class="comment">//相邻两元素比较</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = p-&gt;data[j];       <span class="comment">//交换元素</span></span><br><span class="line">                p-&gt;data[j] = p-&gt;data[j+<span class="number">1</span>];</span><br><span class="line">                p-&gt;data[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_huffmantree</span><span class="params">(num_type *n, Btree_type *bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    bt-&gt;num = n-&gt;length;</span><br><span class="line">    Btree_node *root, *lchild, *rchild;</span><br><span class="line">    </span><br><span class="line">    lchild = (Btree_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Btree_node));</span><br><span class="line">    rchild = (Btree_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Btree_node));</span><br><span class="line">    lchild-&gt;data = n-&gt;data[<span class="number">0</span>];</span><br><span class="line">    rchild-&gt;data = n-&gt;data[<span class="number">1</span>];</span><br><span class="line">    lchild-&gt;Lchild = <span class="literal">NULL</span>;</span><br><span class="line">    lchild-&gt;Rchild = <span class="literal">NULL</span>;</span><br><span class="line">    rchild-&gt;Lchild = <span class="literal">NULL</span>;</span><br><span class="line">    rchild-&gt;Rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>; i &lt; n-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        root = (Btree_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Btree_node));</span><br><span class="line">        root-&gt;Lchild = lchild;</span><br><span class="line">        root-&gt;Rchild = rchild;</span><br><span class="line">        root-&gt;data = lchild-&gt;data + rchild-&gt;data;</span><br><span class="line">        rchild = (Btree_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Btree_node));</span><br><span class="line">        rchild-&gt;data = n-&gt;data[i];</span><br><span class="line">        rchild-&gt;Lchild = <span class="literal">NULL</span>;</span><br><span class="line">        rchild-&gt;Rchild = <span class="literal">NULL</span>;</span><br><span class="line">        lchild = root;</span><br><span class="line">    &#125;                             <span class="comment">//循环生成huffman树</span></span><br><span class="line">    bt-&gt;root = (Btree_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Btree_node));</span><br><span class="line">    bt-&gt;root-&gt;Lchild = lchild;</span><br><span class="line">    bt-&gt;root-&gt;Rchild = rchild;</span><br><span class="line">    bt-&gt;root-&gt;data = lchild-&gt;data + rchild-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_binary_code</span><span class="params">(num_type *n, Btree_node *bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Btree_node *root;</span><br><span class="line">    <span class="comment">//root = (Btree_node *)malloc(sizeof(Btree_node));</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-&gt;length; i++)</span><br><span class="line">    &#123; </span><br><span class="line">        root = bt;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The binary code of %d is:&quot;</span>, n-&gt;data[i]);</span><br><span class="line">        <span class="keyword">while</span>(root-&gt;Lchild != <span class="literal">NULL</span> &amp;&amp; root-&gt;Rchild != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;Rchild-&gt;data == n-&gt;data[i]) </span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;Lchild-&gt;data == n-&gt;data[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                    root = root-&gt;Lchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if(root != NULL) free(root);     </span></span><br><span class="line">    <span class="comment">//这个地方不可以释放！！！！  why？？？  不是重新分配了一块空间🐎？</span></span><br><span class="line">    <span class="comment">//因为不需要分配。。。。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_btree</span><span class="params">(Btree_node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;Lchild != <span class="literal">NULL</span>) destroy_btree(root-&gt;Lchild);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;Rchild != <span class="literal">NULL</span>) destroy_btree(root-&gt;Rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">&#125;  <span class="comment">//为什么会有问题？？？？？？？ </span></span><br><span class="line"><span class="comment">//bug   root是静态内存分配</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num_type n;</span><br><span class="line">    n.length = <span class="number">0</span>;</span><br><span class="line">    Btree_type b;</span><br><span class="line">    b.num = <span class="number">0</span>;</span><br><span class="line">    read_weightnum(&amp;n);</span><br><span class="line">    Bubble_Sort(&amp;n);      <span class="comment">//将权值从小到大排序</span></span><br><span class="line">    create_huffmantree(&amp;n, &amp;b);</span><br><span class="line">    print_binary_code(&amp;n, b.root);</span><br><span class="line">    destroy_btree(b.root);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Ex4-3"><a href="#Ex4-3" class="headerlink" title="Ex4-3"></a>Ex4-3</h4><ul>
<li>设A和B是稀疏矩阵，都以三元组作为存储结构；</li>
<li>编写矩阵相加的算法，结果存放在三元组表C中，并分析时间复杂度。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNUM 30</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">&#125;triple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    triple data[MAXNUM];</span><br><span class="line">    <span class="keyword">int</span> ru, cu, tu;</span><br><span class="line">&#125;TSMMatrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_TSMmatrix</span><span class="params">(TSMMatrix *TM)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the ru,cu and tu&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;TM-&gt;ru, &amp;TM-&gt;cu, &amp;TM-&gt;tu);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPlease enter the data ending with 0:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TM-&gt;data[i].row = x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        TM-&gt;data[i].col = x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        TM-&gt;data[i].e = x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; MAXNUM)</span><br><span class="line">    &#123;</span><br><span class="line">        TM-&gt;data[i].row = <span class="number">0</span>;</span><br><span class="line">        TM-&gt;data[i].col = <span class="number">0</span>;</span><br><span class="line">        TM-&gt;data[i].e = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addition_matrix</span><span class="params">(TSMMatrix *M1, TSMMatrix *M2, TSMMatrix *M3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !(M1-&gt;cu == M2-&gt;cu &amp;&amp; M1-&gt;ru == M2-&gt;ru) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;These two matrices can`t be added\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    M3-&gt;cu = M1-&gt;cu; M3-&gt;ru = M1-&gt;ru; M3-&gt;tu = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//int m1[M1-&gt;ru][M1-&gt;cu]=&#123;0&#125;, m2[M2-&gt;ru][M2-&gt;cu]=&#123;0&#125;, m3[M3-&gt;ru][M3-&gt;cu]=&#123;0&#125;;</span></span><br><span class="line">    <span class="keyword">int</span> m1[M1-&gt;ru][M1-&gt;cu], m2[M2-&gt;ru][M2-&gt;cu], m3[M3-&gt;ru][M3-&gt;cu];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; M1-&gt;ru; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; M1-&gt;cu; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            m1[i][j] = <span class="number">0</span>;</span><br><span class="line">            m2[i][j] = <span class="number">0</span>;</span><br><span class="line">            m3[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; M1-&gt;tu; i++)</span><br><span class="line">        m1[M1-&gt;data[i].row<span class="number">-1</span>][M1-&gt;data[i].col<span class="number">-1</span>] = M1-&gt;data[i].e;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; M2-&gt;tu; i++)</span><br><span class="line">        m2[M2-&gt;data[i].row<span class="number">-1</span>][M2-&gt;data[i].col<span class="number">-1</span>] = M2-&gt;data[i].e;</span><br><span class="line">    <span class="comment">//将M1和M2变成稀疏矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; M3-&gt;ru; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; M3-&gt;cu; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            m3[i][j] = m1[i][j] + m2[i][j];</span><br><span class="line">            <span class="keyword">if</span>(m3[i][j] != <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                M3-&gt;tu++;</span><br><span class="line">                M3-&gt;data[M3-&gt;tu<span class="number">-1</span>].e = m3[i][j];</span><br><span class="line">                M3-&gt;data[M3-&gt;tu<span class="number">-1</span>].row = i+<span class="number">1</span>;</span><br><span class="line">                M3-&gt;data[M3-&gt;tu<span class="number">-1</span>].col = j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//构建矩阵的和M3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// M3-&gt;cu = M1-&gt;cu;</span></span><br><span class="line">    <span class="comment">// M3-&gt;ru = M1-&gt;ru;</span></span><br><span class="line">    <span class="comment">// M3-&gt;tu = 0;</span></span><br><span class="line">    <span class="comment">// for(int i=0; i &lt; M1-&gt;tu; i++)</span></span><br><span class="line">    <span class="comment">//     for(int j=0; j &lt; M2-&gt;tu; j++)</span></span><br><span class="line">    <span class="comment">//         for(int r=1; r &lt;= M3-&gt;ru; r++)</span></span><br><span class="line">    <span class="comment">//             for(int c=1; c &lt;= M3-&gt;cu; c++)</span></span><br><span class="line">    <span class="comment">//             &#123;</span></span><br><span class="line">    <span class="comment">//                 if(M1-&gt;data[i].row == r)</span></span><br><span class="line">    <span class="comment">//                 &#123;</span></span><br><span class="line">    <span class="comment">//                     if(M2-&gt;data[j].row == r)</span></span><br><span class="line">    <span class="comment">//                     &#123;</span></span><br><span class="line">    <span class="comment">//                         if(M1-&gt;data[i].col == r &amp;&amp; M2-&gt;data[j].col == c)</span></span><br><span class="line">    <span class="comment">//                         &#123;</span></span><br><span class="line">    <span class="comment">//                             M3-&gt;data[M3-&gt;tu].e = M1-&gt;data[i].e + M2-&gt;data[j].e;</span></span><br><span class="line">    <span class="comment">//                             M3-&gt;tu++;</span></span><br><span class="line">    <span class="comment">//                             M3-&gt;data[M3-&gt;tu].row = M1-&gt;data[i].row;</span></span><br><span class="line">    <span class="comment">//                             M3-&gt;data[M3-&gt;tu].col = M1-&gt;data[i].col;</span></span><br><span class="line">    <span class="comment">//                         &#125;</span></span><br><span class="line">    <span class="comment">//                         else</span></span><br><span class="line">    <span class="comment">//                         &#123;</span></span><br><span class="line">    <span class="comment">//                             if(M1-&gt;data[i].col &lt; M2-&gt;data[j].col)   //根据列的顺序确定存入顺序</span></span><br><span class="line">    <span class="comment">//                             &#123;</span></span><br><span class="line">    <span class="comment">//                                 M3-&gt;data[M3-&gt;tu].e = M1-&gt;data[i].e;</span></span><br><span class="line">    <span class="comment">//                                 M3-&gt;tu++;</span></span><br><span class="line">    <span class="comment">//                                 M3-&gt;data[M3-&gt;tu].row = M1-&gt;data[i].row;</span></span><br><span class="line">    <span class="comment">//                                 M3-&gt;data[M3-&gt;tu].col = M1-&gt;data[i].col;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//                                 M3-&gt;data[M3-&gt;tu].e = M2-&gt;data[j].e;</span></span><br><span class="line">    <span class="comment">//                                 M3-&gt;tu++;</span></span><br><span class="line">    <span class="comment">//                                 M3-&gt;data[M3-&gt;tu].row = M2-&gt;data[j].row;</span></span><br><span class="line">    <span class="comment">//                                 M3-&gt;data[M3-&gt;tu].col = M2-&gt;data[j].col;</span></span><br><span class="line">    <span class="comment">//                             &#125;</span></span><br><span class="line">    <span class="comment">//                             else</span></span><br><span class="line">    <span class="comment">//                             &#123;</span></span><br><span class="line">    <span class="comment">//                                 M3-&gt;data[M3-&gt;tu].e = M2-&gt;data[j].e;</span></span><br><span class="line">    <span class="comment">//                                 M3-&gt;tu++;</span></span><br><span class="line">    <span class="comment">//                                 M3-&gt;data[M3-&gt;tu].row = M2-&gt;data[j].row;</span></span><br><span class="line">    <span class="comment">//                                 M3-&gt;data[M3-&gt;tu].col = M2-&gt;data[j].col;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//                                 M3-&gt;data[M3-&gt;tu].e = M1-&gt;data[i].e;</span></span><br><span class="line">    <span class="comment">//                                 M3-&gt;tu++;</span></span><br><span class="line">    <span class="comment">//                                 M3-&gt;data[M3-&gt;tu].row = M1-&gt;data[i].row;</span></span><br><span class="line">    <span class="comment">//                                 M3-&gt;data[M3-&gt;tu].col = M1-&gt;data[i].col;</span></span><br><span class="line">    <span class="comment">//                             &#125;</span></span><br><span class="line">    <span class="comment">//                         &#125;  </span></span><br><span class="line">    <span class="comment">//                     &#125;</span></span><br><span class="line">    <span class="comment">//                     else</span></span><br><span class="line">    <span class="comment">//                     &#123;</span></span><br><span class="line">    <span class="comment">//                         M3-&gt;data[M3-&gt;tu].e = M1-&gt;data[i].e;</span></span><br><span class="line">    <span class="comment">//                         M3-&gt;data[M3-&gt;tu].row = M1-&gt;data[i].row;</span></span><br><span class="line">    <span class="comment">//                         M3-&gt;data[M3-&gt;tu].col = M1-&gt;data[i].col;</span></span><br><span class="line">    <span class="comment">//                         M3-&gt;tu++;</span></span><br><span class="line">    <span class="comment">//                         //将M1[i]放进去</span></span><br><span class="line">    <span class="comment">//                     &#125;</span></span><br><span class="line">                        </span><br><span class="line">    <span class="comment">//                 &#125;</span></span><br><span class="line">    <span class="comment">//                 else</span></span><br><span class="line">    <span class="comment">//                 &#123;</span></span><br><span class="line">    <span class="comment">//                     if(M2-&gt;data[j].row == r)</span></span><br><span class="line">    <span class="comment">//                     &#123;</span></span><br><span class="line">    <span class="comment">//                         M3-&gt;data[M3-&gt;tu].e = M2-&gt;data[j].e;</span></span><br><span class="line">    <span class="comment">//                         M3-&gt;data[M3-&gt;tu].row = M2-&gt;data[j].row;</span></span><br><span class="line">    <span class="comment">//                         M3-&gt;data[M3-&gt;tu].col = M2-&gt;data[j].col;</span></span><br><span class="line">    <span class="comment">//                         M3-&gt;tu++;</span></span><br><span class="line">    <span class="comment">//                         //将M2[j]放进去</span></span><br><span class="line">    <span class="comment">//                     &#125;</span></span><br><span class="line">    <span class="comment">//                     else continue;</span></span><br><span class="line">    <span class="comment">//                 &#125;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_TSMMatrix</span><span class="params">(TSMMatrix *TM)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, TM-&gt;ru, TM-&gt;cu, TM-&gt;tu);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; TM-&gt;tu; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, TM-&gt;data[i].row, TM-&gt;data[i].col, TM-&gt;data[i].e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TSMMatrix A, B, C;</span><br><span class="line">    create_TSMmatrix(&amp;A);</span><br><span class="line">    create_TSMmatrix(&amp;B);</span><br><span class="line">    <span class="keyword">int</span> a=addition_matrix(&amp;A, &amp;B, &amp;C);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The matrix A is :\n&quot;</span>);</span><br><span class="line">    print_TSMMatrix(&amp;A);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The matrix B is :\n&quot;</span>);</span><br><span class="line">    print_TSMMatrix(&amp;B);</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The addition matrix is:\n&quot;</span>);</span><br><span class="line">        print_TSMMatrix(&amp;C);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Ex4-4"><a href="#Ex4-4" class="headerlink" title="Ex4-4"></a>Ex4-4</h4><ul>
<li>已知8*8的迷宫，可表示为图的邻接矩阵；</li>
<li>编写算法，求出从入口到出口的最短路径；</li>
<li>main函数中输入入口和出口的序号，输出最短路径。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNUM 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 0</span></span><br><span class="line"><span class="comment">//邻接矩阵类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> node[MAXNUM];</span><br><span class="line">    <span class="keyword">int</span> arcs[MAXNUM][MAXNUM];</span><br><span class="line">&#125;graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> node[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> path[<span class="number">20</span>][MAXNUM];</span><br><span class="line">&#125;path_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_graph</span><span class="params">(graph *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXNUM; i++)</span><br><span class="line">        g-&gt;node[i] = i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    g-&gt;arcs[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">7</span>;</span><br><span class="line">    g-&gt;arcs[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">3</span>;</span><br><span class="line">    g-&gt;arcs[<span class="number">0</span>][<span class="number">5</span>] = <span class="number">11</span>;</span><br><span class="line">    g-&gt;arcs[<span class="number">1</span>][<span class="number">5</span>] = <span class="number">4</span>;</span><br><span class="line">    g-&gt;arcs[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">7</span>;</span><br><span class="line">    g-&gt;arcs[<span class="number">2</span>][<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line">    g-&gt;arcs[<span class="number">2</span>][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">    g-&gt;arcs[<span class="number">2</span>][<span class="number">7</span>] = <span class="number">15</span>;</span><br><span class="line">    g-&gt;arcs[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">9</span>;</span><br><span class="line">    g-&gt;arcs[<span class="number">3</span>][<span class="number">6</span>] = <span class="number">2</span>;</span><br><span class="line">    g-&gt;arcs[<span class="number">4</span>][<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">    g-&gt;arcs[<span class="number">5</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">    g-&gt;arcs[<span class="number">5</span>][<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">    g-&gt;arcs[<span class="number">5</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    g-&gt;arcs[<span class="number">6</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    g-&gt;arcs[<span class="number">6</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">    g-&gt;arcs[<span class="number">7</span>][<span class="number">2</span>] = <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(graph *g, path_type *p, <span class="keyword">int</span> ent, <span class="keyword">int</span> <span class="built_in">exit</span>, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> visit[], <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ent == <span class="built_in">exit</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        visit[MAXNUM] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        m++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visit[ent<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXNUM; i++)</span><br><span class="line">        <span class="keyword">while</span>(g-&gt;arcs[ent<span class="number">-1</span>][i] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(g, p, i, <span class="built_in">exit</span>, m, n+<span class="number">1</span>, visit, flag);</span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">                &#123; </span><br><span class="line">                    p-&gt;path[m][n] = i;</span><br><span class="line">                    p-&gt;node[m] = p-&gt;node[m] + g-&gt;arcs[ent<span class="number">-1</span>][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">0</span>) flag=<span class="number">0</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fshortest_path</span><span class="params">(graph *g, <span class="keyword">int</span> ent, <span class="keyword">int</span> <span class="built_in">exit</span>, path_type *p, <span class="keyword">int</span> visit[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfs(g, p, ent, <span class="built_in">exit</span>, <span class="number">-1</span>, <span class="number">0</span>, visit, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    graph m;</span><br><span class="line">    <span class="keyword">int</span> ent, <span class="built_in">exit</span>;</span><br><span class="line">    path_type p; <span class="comment">//存储路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXNUM; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;MAXNUM; j++)</span><br><span class="line">            m.arcs[i][j] = <span class="number">0</span>; </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            p.path[i][j] = <span class="number">0</span>;</span><br><span class="line">            p.node[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> visit[MAXNUM] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the entrance and exit\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;ent, &amp;<span class="built_in">exit</span>);</span><br><span class="line">    create_graph(&amp;m);</span><br><span class="line">    fshortest_path(&amp;m, ent, <span class="built_in">exit</span>, &amp;p, visit);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The shortest path is :&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, method;;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span>(p.node[i] != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.node[i] &lt; s)</span><br><span class="line">        &#123;</span><br><span class="line">            s = p.node[i];</span><br><span class="line">            method = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p.path[method][j] != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, &amp;p.path[method][j]);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="floyd解法"><a href="#floyd解法" class="headerlink" title="floyd解法"></a>floyd解法</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MGraph</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> numVertexes;</span><br><span class="line">    <span class="keyword">int</span> *vex;</span><br><span class="line">    <span class="keyword">int</span> arc[MAXVEX][MAXVEX];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> PathMatrix[MAXVEX][MAXVEX];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ShortPathTable[MAXVEX][MAXVEX];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Floyd</span><span class="params">(MGraph *G,PathMatrix *P,ShortPathTable *D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v,w,k;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G-&gt;numVertexes;++v)&#123;   </span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G-&gt;numVertexes;++w)&#123;</span><br><span class="line">            (*D)[v][w]=G-&gt;arc[v][w];</span><br><span class="line">            (*P)[v][w]=w;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G-&gt;numVertexes;++k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G-&gt;numVertexes;++v)&#123;</span><br><span class="line">            <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G-&gt;numVertexes;++w)&#123;</span><br><span class="line">                <span class="keyword">if</span>( (*D)[v][w]&gt;(*D)[v][k]+(*D)[k][w] )  <span class="comment">// (v到w的距离) VS (v到k的距离+k到w的距离)&#123;</span></span><br><span class="line">                    (*D)[v][w]=(*D)[v][k]+(*D)[k][w];</span><br><span class="line">                    (*P)[v][w]=(*P)[v][k]; <span class="comment">//若从v出发，要去w则先要从v去到k，“再作下一步打算(下一步即(*P)[k][w])”</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    MGraph *my_g=(struct MGraph*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct MGraph));    </span><br><span class="line">    <span class="keyword">int</span> i,j;    </span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> v0=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> vv=<span class="number">8</span>;  </span><br><span class="line">  </span><br><span class="line">    my_g-&gt;numVertexes=MAXVEX;    </span><br><span class="line">    my_g-&gt;vex=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*my_g-&gt;numVertexes);    </span><br><span class="line">    <span class="keyword">if</span>(!my_g-&gt;vex) <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;my_g-&gt;numVertexes;++i)  <span class="comment">//一维数组(图中各结点)初始化&#123;0,1,2,3,4,5,6,7,8&#125;    </span></span><br><span class="line">        my_g-&gt;vex[i]=i++;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;my_g-&gt;numVertexes;++i)    </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;my_g-&gt;numVertexes;++j)    </span><br><span class="line">            my_g-&gt;arc[i][j]=INFINITY;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 无向图的权值二维数组为对称矩阵  </span></span><br><span class="line">    my_g-&gt;arc[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;  my_g-&gt;arc[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">5</span>;  </span><br><span class="line">    my_g-&gt;arc[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">3</span>;  my_g-&gt;arc[<span class="number">1</span>][<span class="number">3</span>]=<span class="number">7</span>;  my_g-&gt;arc[<span class="number">1</span>][<span class="number">4</span>]=<span class="number">5</span>;    </span><br><span class="line">    my_g-&gt;arc[<span class="number">2</span>][<span class="number">4</span>]=<span class="number">1</span>;  my_g-&gt;arc[<span class="number">2</span>][<span class="number">5</span>]=<span class="number">7</span>;  </span><br><span class="line">    my_g-&gt;arc[<span class="number">3</span>][<span class="number">4</span>]=<span class="number">2</span>;  my_g-&gt;arc[<span class="number">3</span>][<span class="number">6</span>]=<span class="number">3</span>;  </span><br><span class="line">    my_g-&gt;arc[<span class="number">4</span>][<span class="number">5</span>]=<span class="number">3</span>;  my_g-&gt;arc[<span class="number">4</span>][<span class="number">6</span>]=<span class="number">6</span>;  my_g-&gt;arc[<span class="number">4</span>][<span class="number">7</span>]=<span class="number">9</span>;  </span><br><span class="line">    my_g-&gt;arc[<span class="number">5</span>][<span class="number">7</span>]=<span class="number">5</span>;  </span><br><span class="line">    my_g-&gt;arc[<span class="number">6</span>][<span class="number">7</span>]=<span class="number">2</span>;  my_g-&gt;arc[<span class="number">6</span>][<span class="number">8</span>]=<span class="number">7</span>;  </span><br><span class="line">    my_g-&gt;arc[<span class="number">7</span>][<span class="number">8</span>]=<span class="number">4</span>;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;my_g-&gt;numVertexes;++i)    </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=i;++j)    </span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">if</span>(i==j)    </span><br><span class="line">            &#123;    </span><br><span class="line">                my_g-&gt;arc[i][j]=<span class="number">0</span>;    </span><br><span class="line">                <span class="keyword">continue</span>;    </span><br><span class="line">            &#125;    </span><br><span class="line">            my_g-&gt;arc[i][j]=my_g-&gt;arc[j][i];    </span><br><span class="line">        &#125;    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;my_g-&gt;numVertexes;++i)  <span class="comment">//二维数组表示图中各结点间连接边的weight    </span></span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;my_g-&gt;numVertexes;++j)    </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d  &quot;</span>,my_g-&gt;arc[i][j]);    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    PathMatrix D;</span><br><span class="line">    ShortPathTable P;</span><br><span class="line">    ShortestPath_Floyd(my_g,&amp;P,&amp;D);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXVEX;++i)  <span class="comment">//二维数组表示图中各结点间连接边的weight    </span></span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAXVEX;++j)    </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d  &quot;</span>,P[i][j]);    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">free</span>(my_g-&gt;vex);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="dijkstra解法"><a href="#dijkstra解法" class="headerlink" title="dijkstra解法"></a>dijkstra解法</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VertexNum  9  <span class="comment">//实际上共有六个顶点（1---6）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EdgeNum  9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Graph[VertexNum][VertexNum] =</span><br><span class="line"><span class="comment">//0  1  2  3  4  5  6  7  8</span></span><br><span class="line">&#123; X, X, X, X, X, X, X, X, X, <span class="comment">//0</span></span><br><span class="line">  X, X, <span class="number">6</span>, <span class="number">3</span>, X, X, X, <span class="number">8</span>, X, <span class="comment">//1</span></span><br><span class="line">  X, X, X, X, <span class="number">5</span>, X, X, X, <span class="number">5</span>, <span class="comment">//2</span></span><br><span class="line">  X, X, <span class="number">2</span>, X, <span class="number">3</span>, <span class="number">4</span>, X, X, X, <span class="comment">//3</span></span><br><span class="line">  X, X, X, X, X, X, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="comment">//4</span></span><br><span class="line">  X, X, X, X, <span class="number">2</span>, X, <span class="number">5</span>, X, X, <span class="comment">//5</span></span><br><span class="line">  X, X, X, X, X, X, X, <span class="number">3</span>, <span class="number">16</span>, <span class="comment">//6</span></span><br><span class="line">  X, <span class="number">4</span>, X, X, X, X, X, X, X,  <span class="comment">//7</span></span><br><span class="line">  X, X, X, X, <span class="number">6</span>, X, X, <span class="number">9</span>, X  <span class="comment">//8 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Visited[VertexNum];</span><br><span class="line"><span class="keyword">int</span> path[VertexNum];</span><br><span class="line"><span class="keyword">int</span> Distance[VertexNum];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> Begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> MinEdge, Vertex, i,j, Edges;</span><br><span class="line">  Edges = <span class="number">1</span>;</span><br><span class="line">  Visited[Begin] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i&lt;VertexNum; i++) Distance[i] = Graph[Begin][i];</span><br><span class="line"></span><br><span class="line">  Distance[Begin] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;     1  2  3  4  5  6  7  8\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;-----------------------------------\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;s:%d&quot;</span>, Edges);</span><br><span class="line">  <span class="keyword">for</span>( i=<span class="number">1</span>; i&lt;VertexNum; i++)</span><br><span class="line">  <span class="keyword">if</span> (Distance[i] == X) <span class="built_in">printf</span>(<span class="string">&quot;  *&quot;</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,Distance[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span>( Edges&lt;VertexNum<span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    Edges++; MinEdge = X;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;VertexNum; j++)</span><br><span class="line">    <span class="keyword">if</span> (Visited[j]==<span class="number">0</span> &amp;&amp; MinEdge &gt; Distance[j] )</span><br><span class="line">    &#123;</span><br><span class="line"> Vertex = j; MinEdge = Distance[j];</span><br><span class="line">    &#125;</span><br><span class="line">    Visited[Vertex] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s:%d&quot;</span>,Edges);</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;VertexNum; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (Visited[j] == <span class="number">0</span> &amp;&amp; Distance[Vertex] + Graph[Vertex][j] &lt;Distance[j])</span><br><span class="line">      &#123;   Distance[j] = Distance[Vertex] + Graph[Vertex][j];</span><br><span class="line">   path[j] = Vertex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//printf(&quot;%6d&quot;,Distance[j]);</span></span><br><span class="line">       <span class="keyword">if</span> (Distance[j] == X) <span class="built_in">printf</span>(<span class="string">&quot;  *&quot;</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,Distance[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> k;</span><br><span class="line"> <span class="comment">// clrscr();</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;VertexNum; i++) &#123; Visited[i] = <span class="number">0</span>;  path[i] = <span class="number">1</span>;&#125;</span><br><span class="line">  <span class="keyword">int</span> x, y;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;please enter the entrance x and exit y:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">  Dijkstra(x);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n All Path------------------------- \n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;VertexNum; i++) <span class="comment">//printf(&quot;%5d&quot;,Visited[i]);</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;[%d] &quot;</span>,Distance[i]);</span><br><span class="line">     k = i;</span><br><span class="line">     <span class="keyword">do</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d&lt;--&quot;</span>,k);</span><br><span class="line">       k  = path[k];</span><br><span class="line">     &#125; <span class="keyword">while</span> (k!=<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nThe shortest path from x to y is:\n&quot;</span>);</span><br><span class="line">  k = y;</span><br><span class="line">     <span class="keyword">do</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d&lt;--&quot;</span>,k);</span><br><span class="line">       k  = path[k];</span><br><span class="line">     &#125; <span class="keyword">while</span> (k!=<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;1 \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nThe shortest distance is %d&quot;</span>, Distance[y]);</span><br><span class="line">  getchar();</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>道歉信</title>
    <url>/2022/05/20/daoqian/</url>
    <content><![CDATA[<hr>
<p>此封道歉信将置顶一周，以表本人对于Honora同学的愧疚和歉意。同时也时刻提醒本人不要忘记在2022.5.20号中午时分所犯下的严重错误，从此以后绝不再犯，引以为戒。</p>
<p>谢谢Honara同学对我的容忍和宽宏，一定要牢记，不要辜负这份宽容。</p>
<hr>
]]></content>
  </entry>
</search>
